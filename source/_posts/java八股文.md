---
title: java八股文
date: 2024-03-18 17:14:43
tags: 面试题
feature: true
---

# 1、JAVA

## 一、@Resource和@Autowire注解的区别

@Resource和@Autowired都是用来进行依赖注入的注解，但是它们有一些不同之处。

@Autowired是Spring框架中的注解，它可以用来标注字段、构造函数、方法等，表示需要自动装配。它可以用来注入依赖的bean。如果有多个bean符合条件，可能会抛出异常。

@Resource是Java自带的注解，它可以用来标注字段、方法等，表示需要自动装配。它可以用来注入依赖的bean。如果有多个bean符合条件，会按照名称进行匹配。

总结:

@Autowired 是 Spring 框架中的注解，用来标注需要自动装配的 bean。
@Resource 是 Java 自带的注解，用来标注需要自动装配的 bean。
@Autowired 是按类型装配，如果有多个同类型的 bean，会抛出异常； @Resource 是按名称装配，如果名称不存在，会使用类型装配。

## 2、重载与重写区别    难度系数：⭐

1. 重载发生在本类，重写发生在父类与子类之间
2. 重载的方法名必须相同，重写的方法名相同且返回值类型必须相同
3. 重载的参数列表不同，重写的参数列表必须相同
4. 重写的访问权限不能比父类中被重写的方法的访问权限更低
5. 构造方法不能被重写

## 12、普通类和抽象类有哪些区别？★★★★★

抽象类不能被实例化；
抽象类可以有抽象方法，只需申明，无须实现；
有抽象方法的类一定是抽象类；
抽象类的子类必须实现抽象类中的所有抽象方法，否则子类仍然是抽象类；
抽象方法不能声明为静态、不能被static、final修饰。

## 13、接口和抽象类有什么区别？★★★★★

（1）接口

接口使用interface修饰；
接口不能实例化；
类可以实现多个接口；

①java8之前，接口中的方法都是抽象方法，省略了public abstract。②java8之后；接口中可以定义静态方法，静态方法必须有方法体，普通方法没有方法体，需要被实现；

（2）抽象类

抽象类使用abstract修饰；
抽象类不能被实例化；
抽象类只能单继承；
抽象类中可以包含抽象方法和非抽象方法，非抽象方法需要有方法体；
如果一个类继承了抽象类，①如果实现了所有的抽象方法，子类可以不是抽象类；②如果没有实现所有的抽象方法，子类仍然是抽象类。

共同点 不能实例化；

不同点 接口使用interface修饰；抽象类使用abstract修饰；

## 6、String、StringBuffer、StringBuilder 有什么区别？★★★★★

String、StringBuffer、StringBuilder 最大的不同是 String 不可变，后者可变。StringBuffer 是线

程安全的，StringBuilder 线程不安全速度较快。

## 7、String.trim()方法去掉的是哪些字符？

trim 去掉字符串首尾的空白字符。

## 8、String 可以被子类继承吗？

既然 String 是 final 的，所以不能被继承。

## 9、可以自定义 java.lang.String 类并使用吗？

可以自定义 java.lang.String 类并编译成功，但不能被加载使用，具体请学习类加载机制。

## 10、String 与 byte[]两者相互之间如何转换？

String > byte[] 通过 String 类的 getBytes 方法；byte[] > String 通过 new String(byte[])构造器。

## 11、==和 equals ⽅法的区别

==：如果是基本数据类型，⽐较是值，如果是引⽤类型，⽐较的是引⽤地址

equals：具体看各个类重写 equals ⽅法之后的⽐较逻辑，⽐如 String 类，虽然是引⽤类型，但是 String 类中重写了 equals ⽅法，⽅法内部⽐较的是字符串中的各个字符是否全部相等。

### 2、== 和 [equals](https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020) 的区别是什么？

1. 对于基本类型，==比较的是值；
2. 对于引用类型，==比较的是地址；
3. equals不能用于基本类型的比较；
4. 如果没有重写equals，equals就相当于==；
5. 如果重写了equals方法，equals比较的是对象的内容；

## 12、 hashCode()与 equals()之间的关系★★★★★

6 在 Java 中，每个对象都可以调⽤⾃⼰的 hashCode()⽅法得到⾃⼰的哈希值(hashCode)，相当于对象的 指纹信息，通常来说世界上没有完全相同的两个指纹，但是在 Java 中做不到这么绝对，但是我们仍然可 以利⽤ hashCode 来做⼀些提前的判断，⽐如： 如果两个对象的 hashCode 不相同，那么这两个对象肯定不同的两个对象 如果两个对象的 hashCode 相同，不代表这两个对象⼀定是同⼀个对象，也可能是两个对象 如果两个对象相等，那么他们的 hashCode 就⼀定相同 在 Java 的⼀些集合类的实现中，在⽐较两个对象是否相等时，会根据上⾯的原则，会先调⽤对象的 hashCode()⽅法得到 hashCode 进⾏⽐较，如果 hashCode 不相同，就可以直接认为这两个对象不相 同，如果 hashCode 相同，那么就会进⼀步调⽤ equals()⽅法进⾏⽐较。⽽ equals()⽅法，就是⽤来最终 确定两个对象是不是相等的，通常 equals ⽅法的实现会⽐较重，逻辑⽐较多，⽽ hashCode()主要就是得 到⼀个哈希值，实际上就⼀个数字，相对⽽⾔⽐较轻，所以在⽐较两个对象时，通常都会先根据 hashCode 想⽐较⼀下。 所以我们就需要注意，如果我们重写了 equals()⽅法，那么就要注意 hashCode()⽅法，⼀定要保证能遵 守上述规则。

13、重载和重写的区别

- 重载是指在一个类中定义了多个同名的方法，但他们的参数列表是不同的
- 子[类继承](https://so.csdn.net/so/search?q=%E7%B1%BB%E7%BB%A7%E6%89%BF&spm=1001.2101.3001.7020)父类，子类重写父类中的所有公共方法，覆盖父类的方法并对其重写。

重载

```java
public static int add(int x, int y) {
        return x + y;
    }
    public static double add(int x, int y) {
        return x + y;
    }
```

重写

```java
class Animal {
    public void eat(String food) {
 		...
    }
}

class Bird extends Animal {
    @Override
    public void eat(String food) {
		...
    }
```

## 13、String、StringBuffer 和 StringBuilder 的区别是什 么?★★★★★

string 不可变 线程安全 操作少量数据或不操作数据 是个对象 消耗内存性能底

StringBuffer 不可变 线程不安全 频繁操作数据 不考虑线程安全

StringBuilder 不可变 线程安全 频繁操作数据 考虑线程安全 +了 synchronizd(锁)

## 14、 Java 创建对象有几种方式？★★★★★

java 中提供了以下四种创建对象的方式:

1. new 创建新对象
2. 通过反射机制
3. 采用 clone 机制
4. 通过序列化机制

15、 有没有可能两个不相等的对象有相同的 hashcode

有可能.在产生 hash 冲突时,两个不相等的对象就会有相同的 hashcode 值.当 hash 冲突产生时,一般有以 下几种方式来处理:

拉链法:每个哈希表节点都有一个 next 指针,多个哈希表节点可以用 next 指针构成一个单向链表，被 分配到同一个索引上的多个节点可以用这个单向链表进行存储.

开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找 到,并将记录存入

再哈希:又叫双哈希法,有多个不同的 Hash 函数.当发生冲突时,使用第二个,第三个….等哈希函数计算 地址,直到无冲突

## 15、 深拷贝和浅拷贝的区别是什么?★★★★★

### 深拷贝和浅拷贝

深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用。

浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象
深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象
浅拷贝: 基本数据类型+实例对象的地址(这时浅拷贝的两个实例对象地址是同一个, 也就是同一个实例); 深拷贝: 基本数据类型+实例对象地址下的数据(也就是将实例对象也拷贝了一份)

浅拷贝:被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向 原来的对象.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.

深拷贝:被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被 复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都 复制了一遍.

深拷⻉和浅拷⻉就是指对象的拷⻉，⼀个对象中存在两种类型的属性，⼀种是基本数据类型，⼀种是实 例对象的引⽤。 1. 浅拷⻉是指，只会拷⻉基本数据类型的值，以及实例对象的引⽤地址，并不会复制⼀份引⽤地址所 指向的对象，也就是浅拷⻉出来的对象，内部的类属性指向的是同⼀个对象 2. 深拷⻉是指，既会拷⻉基本数据类型的值，也会针对实例对象的引⽤地址所指向的对象进⾏复制， 深拷⻉出来的对象，内部的属性指向的不是同⼀个对象

## 16、 final 有哪些用法? ★★★★★

被 final 修饰的类不可以被继承

被 final 修饰的方法不可以被重写

被 final 修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.

被 final 修饰的方法,JVM 会尝试将其内联,以提高运行效率 被 final 修饰的常量,在编译阶段会存入常量池中.

修饰类：表示类不可被继承 修饰方法：表示方法不可被子类覆盖，但是可以重载 修饰变量：表示变量一旦被赋值就不可以更改它的值。 （1）修饰成员变量 如果 final 修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。 如果 final 修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。

final 在 java 中有什么作用？
（1）用来修饰一个引用

如果引用为基本数据类型，则该引用为常量，该值无法修改；
如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。
如果引用时类的成员变量，则必须当场赋值，否则编译会报错。
（2）用来修饰一个方法

当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。

（3）用来修饰类

当用final修改类时，该类成为最终类，无法被继承。

比如常用的String类就是最终类。

## 7、如何将字符串反转？

将对象封装到stringBuilder中，调用reverse方法反转。

![1709658384085](images/1、JAVA/1709658384085.png)

## 16、 3\*0.1 == 0.3 返回值是什么

false,因为有些浮点数不能完全精确的表示出来.

## 17 Java 中有哪些类加载器★★★★★

JDK ⾃带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。 BootStrapClassLoader 是 ExtClassLoader 的⽗类加载器，默认负责加载%JAVA_HOME%lib 下的 jar 包和 class ⽂件。 ExtClassLoader 是 AppClassLoader 的⽗类加载器，负责加载%JAVA_HOME%/lib/ext ⽂件夹下的 jar 包和 class 类。 AppClassLoader 是⾃定义类加载器的⽗类，负责加载 classpath 下的类⽂件

## 16.hashCode()和 equals()方法有何重要性？★★★★★

### ★★★★★

HashMap 使用 Key 对象的 hashCode()和 equals()方法去决定 key-value 对的索引。点击这里一

文搞懂它们之间的关系。

当我们试着从 HashMap 中获取值的时候，这些方法也会被用到。如果这些方法没有被正确

地实现，在这种情况下，两个不同 Key 也许会产生相同的 hashCode()和 equals()输出，HashMap

将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。

同样的，所有不允许存储重复数据的集合类都使用 hashCode()和 equals()去查找重复，所以

正确实现它们非常重要。equals()和 hashCode()的实现应该遵循以下规则：

1.如果 o1.equals(o2)，那么 o1.hashCode() == o2.hashCode()总是为 true 的。

2.如果 o1.hashCode() == o2.hashCode()，并不意味着 o1.equals(o2)会为 true。

## 17.Map 接口提供了哪些不同的集合视图？

Map 接口提供三个集合视图：

1）Set keyset()：返回 map 中包含的所有 key 的一个 Set 视图。集合是受 map 支持的，map

的变化会在集合中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若 map 被修

改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过 Iterator

更多关注 Java 大后端公众号的 Remove、Set.remove、removeAll、retainAll 和 clear 操作进行元素移除，从 map 中移除对

应的映射。

它不支持 add 和 addAll 操作。

2）Collection values()：返回一个 map 中包含的所有 value 的一个 Collection 视图。这个 collection

受 map 支持的，map 的变化会在 collection 中反映出来，反之亦然。当一个迭代器正在遍历

一个 collection 时，若 map 被修改了（除迭代器自身的移除操作以外），迭代器的结果会变

为未定义。集合支持通过 Iterator 的 Remove、Set.remove、removeAll、retainAll 和 clear 操作

进行元素移除，从 map 中移除对应的映射。它不支持 add 和 addAll 操作。

3）Set<Map.Entry<K,V>> entrySet()：返回一个 map 钟包含的所有映射的一个集合视图。这个

集合受 map 支持的，map 的变化会在 collection 中反映出来，反之亦然。当一个迭代器正在

遍历一个集合时，若 map 被修改了（除迭代器自身的移除操作，以及对迭代器返回的 entry

进行 setValue 外），迭代器的结果会变为未定义。集合支持通过 Iterator 的 Remove、Set.remove、

removeAll、retainAll 和 clear 操作进行元素移除，从 map 中移除对应的映射。它不支持 add

和 addAll 操作。

## hashCode与equals★★★★★

hashCode介绍：
hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是
确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有
hashCode() 函数。
散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用
到了散列码！（可以快速找到所需要的对象）
为什么要有hashCode：
以“HashSet如何检查重复”为例子来说明为什么要有hashCode：
对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有
值，如果没有、HashSet会假设对象没有重复出现。但是如果发现有值，这时会调用equals（）方法来
检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会
重新散列到其他位置。这样就大大减少了equals的次数，相应就大大提高了执行速度。
如果两个对象相等，则hashcode一定也是相同的
两个对象相等,对两个对象分别调用equals方法都返回true
两个对象有相同的hashcode值，它们也不一定是相等的
因此，equals方法被覆盖过，则hashCode方法也必须被覆盖
***hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则******该class的两个
对象无论如何都不会相等（即使这两个对象指向相同的数据）***

## 18.HashMap 和 HashTable 有何不同？

（1）HashMap 允许 key 和 value 为 null，而 HashTable 不允许。

（2）HashTable 是同步的，而 HashMap 不是。所以 HashMap 适合单线程环境，HashTable

适合多线程环境。

（3）在 Java1.4 中引入了 LinkedHashMap，HashMap 的一个子类，假如你想要遍历顺序，你

很容易从 HashMap 转向 LinkedHashMap，但是 HashTable 不是这样的，它的顺序是不可预知

的。

（4）HashMap 提供对 key 的 Set 进行遍历，因此它是 fail-fast 的，但 HashTable 提供对 key

的 Enumeration 进行遍历，它不支持 fail-fast。

（5）HashTable 被认为是个遗留的类，如果你寻求在迭代的时候修改 Map，你应该使用

CocurrentHashMap。

# 集合

## [[java集合超详解\_java集合使用-CSDN博客](https://blog.csdn.net/feiyanaffection/article/details/81394745)]

![1709657326301](images/1、JAVA/1709657326301.png)

![1709657362460](images/1、JAVA/1709657362460.png)

![1709657394941](images/1、JAVA/1709657394941.png)

![1709205810985](images/1、JAVA/1709205810985.png)

[Set](https://pdai.tech/md/java/collection/java-collection-all.html#set)

* [TreeSet](https://pdai.tech/md/java/collection/java-collection-all.html#treeset)
* [HashSet](https://pdai.tech/md/java/collection/java-collection-all.html#hashset)
* [LinkedHashSet](https://pdai.tech/md/java/collection/java-collection-all.html#linkedhashset)

[List](https://pdai.tech/md/java/collection/java-collection-all.html#list)

* [ArrayList ](https://pdai.tech/md/java/collection/java-collection-all.html#arraylist)
* [Vector](https://pdai.tech/md/java/collection/java-collection-all.html#vector)
* [LinkedList](https://pdai.tech/md/java/collection/java-collection-all.html#linkedlist)

[Queue](https://pdai.tech/md/java/collection/java-collection-all.html#queue)

* [LinkedList](https://pdai.tech/md/java/collection/java-collection-all.html#linkedlist-1)
* [PriorityQueue](https://pdai.tech/md/java/collection/java-collection-all.html#priorityqueue)

[Map](https://pdai.tech/md/java/collection/java-collection-all.html#map)

* [TreeMap](https://pdai.tech/md/java/collection/java-collection-all.html#treemap)
* [HashMap](https://pdai.tech/md/java/collection/java-collection-all.html#hashmap)
* [HashTable](https://pdai.tech/md/java/collection/java-collection-all.html#hashtable)
* [LinkedHashMap](https://pdai.tech/md/java/collection/java-collection-all.html#linkedhashmap)

list

ArrayList     底层数据结构是动态数组，查询快，增删慢。线程不安全，效率高

Vector       底层数据结构是数组，查询快，增删慢。线程安全，效率低

LinkedList 底层数据结构是链表，查询慢，增删快 线程不安全，效率高

set

Treeset 红黑树

Hashset

* 底层其实是包装了一个HashMap实现的
* 底层数据结构是数组+链表 + 红黑树
* 具有比较好的读取和查找性能， 可以有null 值
* 通过equals和HashCode来判断两个元素是否相等
* 非线程安全

LinedHashkset

* 继承HashSet，本质是LinkedHashMap实现
* 底层数据结构由哈希表(是一个元素为链表的数组)和双向链表组成。
* 有序的，根据HashCode的值来决定元素的存储位置，同时使用一个链表来维护元素的插入顺序
* 非线程安全，可以有null 值

map

![1709208051453](images/1、JAVA/1709208051453.png)

Hashmap 哈希表

特点是访问速度快，遍历顺序不确定，线程不安全，最多允许一个key为null，允许多个value为null。

* 可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap类。

Treemap 红黑树

* TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。

LinkedHashmap 双向链表

* LinkedHashMap继承了HashMap，是Map接口的哈希表和链接列表实现，它维护着一个双重链接列表，此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。

HashTable

Hashmap底层原理

**HashMap的底层是数组+链表+红黑树实现的。集合put时，通过计算key键的哈希值来放入元素。若有key值相同的哈希值时，会通过链表进行存放，链表长度达到8时会开辟红黑树进行存放，以此提高查询效率**..

## ArrayList 和 Vector 有何异同点？

**ArrayList 和 Vector 在很多时候都很类似。**

（1）两者都是基于索引的，内部由一个数组支持。

（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。

（3）ArrayList 和 Vector 的迭代器实现都是 fail-fast 的。

（4）ArrayList 和 Vector 两者允许 null 值，也可以使用索引值对元素进行随机访问。

**以下是 ArrayList 和 Vector 的不同点。**

（1）Vector 是同步的，而 ArrayList 不是。然而，如果你寻求在迭代的时候对列表进行改变，

你应该使用 CopyOnWriteArrayList。

（2）ArrayList 比 Vector 快，它因为有同步，不会过载。

（3）ArrayList 更加通用，因为我们可以使用 Collections 工具类轻易地获取同步列表和只读

列表。

## ArrayList 和 LinkedList 有何区别？

![1709479433567](images/1、JAVA/1709479433567.png)

ArrayList 和 LinkedList 两者都实现了 List 接口，但是它们之间有些不同。

1）ArrayList 是由 Array 所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，

复杂度为 O(1)，但 LinkedList 存储一系列的节点数据，每个节点都与前一个和下一个节点相

连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引

的节点然后返回元素，时间复杂度为 O(n)，比 ArrayList 要慢。

2）与 ArrayList 相比，在 LinkedList 中插入、添加和删除一个元素会更快，因为在一个元素被

插入到中间的时候，不会涉及改变数组的大小，或更新索引。

3）LinkedList 比 ArrayList 消耗更多的内存，因为 LinkedList 中的每个节点存储了前后节点的

引用。

.哪些集合类提供对元素的随机访问？

ArrayList、HashMap、TreeMap 和 HashTable 类提供对元素的随机访问。

24.哪些集合类是线程安全的？

Vector、HashTable、Properties 和 Stack 是同步类，所以它们是线程安全的，可以在多线程环

境下使用。Java1.5 并发 API 包括一些集合类，允许迭代时修改，因为它们都工作在集合的

克隆上，所以它们在多线程环境中是安全的。

## HashMap 和 HashSet 区别

![1709211409103](images/1、JAVA/1709211409103.png)

## 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同

HashSet 是 Set 接口的主要实现类 ，HashSet 的底层是 HashMap，线程不安全的，可以存储 null
值；
LinkedHashSet 是 HashSet 的子类，能够按照添加的顺序遍历；
TreeSet 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。

# 2、多线程

## sleep(), wait(), join(), yield()区别★★★★★

sleep()和wait
sleep()方法是Thread类的静态本地方法, wait()则是Object类的本地方法(where)
sleep一般用于当前线程休眠，或者轮循暂停操作，wait则多用于多线程之间的通信。(作用)
sleep方法不依赖于同步器synchronized, 但是wait需要依赖synchronized(依赖)
sleep方法不会释放锁, 但是wait会释放锁(锁)
sleep不需要被唤醒（休眠之后推出阻塞)，但是wait需要〈不指定时间需要被别人中断)。(醒)
where 作用 依赖 锁 醒

yield
yield()执行后线程直接进入就绪状态, 马上释放cpu执行权, 但是依然保留cpu的执行资格, 所以cpu下次进行线程调度还可能会让这个线程去的执行权
join()执行后线程进入阻塞状态, 例如在线程B中调用线程A的join(), 那线程B会进入阻塞队列, 直到线程A结束或中断结束
例如t1线程正在执行, t2线程调用了t1.join(), 那线程B就会立即进入阻塞队列, 直到线程A结束或者中断线程

## 线程同步方式

1、Java通过加锁实现线程同步,锁有两类：synchronized和Lock。  2、synchronized加在三个不同的位置,对应三种不同的使用方式,这三种方式的区别是锁对象不同：  （1.）加在普通方法上,则锁是当前的实例（this）。 （2.）加在静态方法上,锁是当前类的Class对象。 （3.）加在代码块上,则需要在关键字后面的小括号里,显式指定一个对象作为锁对象。

## 并发的三大特性

原子性 原子性是指在一个操作中 cpu 不可以在中途暂停然后再调度，即不被中断操作，要不全部执行完成，要 不都不执行。

可见性 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

有序性 虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不一定会按 照我们写的代码 的顺序来执行，有可能将他们重排序。实际上，对于有些代码进行重排序之后，虽然对 变量的值没有造成影响，但有可能会出现线程安全问题。

## 线程有几种状态

![1709658004796](images/1、JAVA/1709658004796.png)

1.线程通常有五种状态，创建，就绪，运行、阻塞和死亡状态。

2.阻塞的情况又分为三种：

(1)、等待阻塞：运行的线程执行 wait 方法，该线程会释放占用的所有资源，JVM 会把该线程放入“等待 池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用 notify 或 notifyAll 方法才能被唤 醒，wait 是 object 类的方法

(2)、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放 入“锁池”中。

(3)、其他阻塞：运行的线程执行 sleep 或 join 方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状 态。当 sleep 状态超时、join 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。 sleep 是 Thread 类的方法 1.新建状态（New）：新创建了一个线程对象。 2.就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的 start 方法。该状态的线程位于 可运行线程池中，变得可运行，等待获取 CPU 的使用权。 3.运行状态（Running）：就绪状态的线程获取了 CPU，执行程序代码。

4.阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程进 入就绪状态，才有机会转到运行状态。 5.死亡状态（Dead）：线程执行完了或者因异常退出了 run 方法，该线程结束生命周期

## juc是什么

JUC即java.util.concurrent,包含了支持并发操作的各种工具。

## \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

# 3、Nginx

## **1、请解释一下什么是 Nginx?**

Nginx 是一个 web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3 和

IMAP 协议。

## **2、请列举 Nginx 的一些特性。**

Nginx 服务器的特性包括：

反向代理/L7 负载均衡器

嵌入式 Perl 解释器

动态二进制升级

可用于重新编写 URL，具有非常好的 PCRE 支持

## **3、请列举 Nginx 和 Apache 之间的不同点**

## **4、请解释 Nginx 如何处理 HTTP 请求。**

Nginx 使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数

据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提

供数万个并发连接。

## **5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?**

只需将请求删除的服务器就可以定义为：

Server {listen 80;server_name “ “ ;return 444;

}

这里，服务器名被保留为一个空字符串，它将在没有“主机”头字段的情况下匹

配请求，而一个特殊的 Nginx 的非标准代码 444 被返回，从而终止连接。

## **6、 使用“反向代理服务器”的优点是什么?**

更多关注 Java 大后端公众号更多关注 Java 大后端公众号

反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务器

之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服务时。

## **7、请列举 Nginx 服务器的最佳用途。**

Nginx 服务器的最佳用法是在网络上部署动态 HTTP 内容，使用 SCGI、WSGI 应用

程序服务器、用于脚本的 FastCGI 处理程序。它还可以作为负载均衡器。

## **8、请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?**

Master 进程：读取及评估配置和维持

Worker 进程：处理请求

## **9、请解释你如何通过不同于 80 的端口开启 Nginx?**

为了通过一个不同的端口开启 Nginx，你必须进入/etc/Nginx/sites-enabled/，

如果这是默认文件，那么你必须打开名为“default”的文件。编辑文件，并放

置在你想要的端口：

Like server { listen 81; }

## **10、请解释是否有可能将 Nginx 的错误替换为 502 错误、503?**

502 =错误网关

503 =服务器超载

有可能，但是您可以确保 fastcgi_intercept_errors 被设置为 ON，并使用错误

页面指令。

Location / {fastcgi_pass 127.0.01:9001;fastcgi_intercept_errors

on;error_page 502 =503/error_page.html;#…}

## **11、在 Nginx 中，解释如何在 URL 中保留双斜线?**

要在 URL 中保留双斜线，就必须使用 merge_slashes_off;

语法:merge_slashes [on/off]更多关注 Java 大后端公众号

默认值: merge_slashes on

环境: http，server

## **12、请解释 ngx_http_upstream_module 的作用是什么?**

ngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi

传递、memcached 传递和 scgi 传递指令来引用的服务器组。

## **13、请解释什么是 C10K 问题?**

C10K 问题是指无法同时处理大量客户端(10,000)的网络套接字。

## **14、请陈述 stub_status 和 sub_filter 指令的作用是什么?**

Stub_status 指令：该指令用于了解 Nginx 当前状态的当前状态，如当前的活动

连接，接受和处理当前读/写/等待连接的总数

Sub_filter 指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据

## **15、解释 Nginx 是否支持将请求压缩到上游?**

您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤器，

它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编码:gzip”来

解压缩响应。

## **16、解释如何在 Nginx 中获得当前的时间?**

要获得 Nginx 的当前时间，必须使用 SSI 模块、$date_gmt 和$date_local 的变

量。

Proxy_set_header THE-TIME $date_gmt;

## **17、用 Nginx 服务器解释-s 的目的是什么?**

用于运行 Nginx -s 参数的可执行文件。

## **18、解释如何在 Nginx 服务器上添加模块?**

在编译过程中，必须选择 Nginx 模块，因为 Nginx 不支持模块的运行时间选择。

## \\\\\\\\

1、请解释一下什么是 Nginx?

Nginx 是一个 web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3

和 IMAP 协议。

2、请列举 Nginx 的一些特性。

Nginx 服务器的特性包括：

反向代理/L7 负载均衡器

嵌入式 Perl 解释器

动态二进制升级

可用于重新编写 URL，具有非常好的 PCRE 支持

3、请列举 Nginx 和 Apache 之间的不同点

4、请解释 Nginx 如何处理 HTTP 请求。

Nginx 使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样

数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可

以提供数万个并发连接。

5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?

只需将请求删除的服务器就可以定义为：

Server {listen 80;server_name “ “ ;return 444;

}

这里，服务器名被保留为一个空字符串，它将在没有“主机”头字段的情况下

匹配请求，而一个特殊的 Nginx 的非标准代码 444 被返回，从而终止连接。

6、 使用“反向代理服务器”的优点是什么?

反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务

器之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服

务时。

7、请列举 Nginx 服务器的最佳用途。Nginx 服务器的最佳用法是在网络上部署动态 HTTP 内容，使用 SCGI、WSGI 应

用程序服务器、用于脚本的 FastCGI 处理程序。它还可以作为负载均衡器。

8、请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?

Master 进程：读取及评估配置和维持

Worker 进程：处理请求

9、请解释你如何通过不同于 80 的端口开启 Nginx?

为了通过一个不同的端口开启 Nginx，你必须进入/etc/Nginx/sites

enabled/，如果这是默认文件，那么你必须打开名为“default”的文件。编辑

文件，并放置在你想要的端口：

Like server { listen 81; }

10、请解释是否有可能将 Nginx 的错误替换为 502 错误、503?

502 =错误网关

503 =服务器超载

有可能，但是您可以确保 fastcgi_intercept_errors 被设置为 ON，并使用错

误页面指令。

Location / {fastcgi_pass 127.0.01:9001;fastcgi_intercept_errors

on;error_page 502 =503/error_page.html;#…}

11、在 Nginx 中，解释如何在 URL 中保留双斜线?

要在 URL 中保留双斜线，就必须使用 merge_slashes_off;

语法:merge_slashes [on/off]

默认值: merge_slashes on

环境: http，server

12、请解释 ngx_http_upstream_module 的作用是什么?

ngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi

传递、memcached 传递和 scgi 传递指令来引用的服务器组。

13、请解释什么是 C10K 问题?C10K 问题是指无法同时处理大量客户端(10,000)的网络套接字。

14、请陈述 stub_status 和 sub_filter 指令的作用是什么?

Stub_status 指令：该指令用于了解 Nginx 当前状态的当前状态，如当前的活

动连接，接受和处理当前读/写/等待连接的总数

Sub_filter 指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据

15、解释 Nginx 是否支持将请求压缩到上游?

您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤

器，它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编

码:gzip”来解压缩响应。

16、解释如何在 Nginx 中获得当前的时间?

要获得 Nginx 的当前时间，必须使用 SSI 模块、\$date_gmt 和\$date_local 的变

量。

Proxy_set_header THE-TIME \$date_gmt;

17、用 Nginx 服务器解释-s 的目的是什么?

用于运行 Nginx -s 参数的可执行文件。

18、解释如何在 Nginx 服务器上添加模块?

在编译过程中，必须选择 Nginx 模块，因为 Nginx 不支持模块的运行时间选

择。

# 4、spring

## 1、springboot

### **1、什么是 Spring Boot？**

Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是

简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。

更多 Spring Boot 详细介绍请看这篇文章《什么是 Spring Boot?》。

### **2、为什么要用 Spring Boot？**

Spring Boot 优点非常多，如：

![1709736051227](images/1、JAVA/1709736051227.png)

 独立运行

 简化配置

 自动配置

 无代码生成和 XML 配置

 应用监控

 上手容易

Spring Boot 集这么多优点于一身，还有理由不使用它呢？

### **5、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？**

启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要

组合包含了以下 3 个注解：

@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。

@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，

如关闭数据源自动配置功能： @SpringBootApplication(exclude =

{ DataSourceAutoConfiguration.class })。

@ComponentScan：Spring 组件扫描。

### **6、开启 Spring Boot 特性有哪几种方式？**

1）继承 spring-boot-starter-parent 项目

2）导入 spring-boot-dependencies 项目依赖

具体请参考这篇文章《Spring Boot 开启的 2 种方式》。

更多关注 Java 大后端公众号**7、Spring Boot 需要独立的容器运行吗？**

可以不需要，内置了 Tomcat/ Jetty 等容器。

### **8、运行 Spring Boot 有哪几种方式？**

1）打包用命令或者放到容器中运行

2）用 Maven/ Gradle 插件运行

3）直接执行 main 方法运行

### **9、Spring Boot 自动配置原理是什么？**

注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动

配置的核心，首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。

Spring Boot 自动配置原理？

@Import + @Configuration + Spring spi 图灵学院 自动配置类由各个 starter 提供，使用@Configuration + @Bean 定义配置类，放到 METAINF/spring.factories 下 使用 Spring spi 扫描 META-INF/spring.factories 下的配置类 使用@Import 导入自动配置类具体看这篇文章《Spring Boot 自动配置原理、实战》。

## 2、spring MVC

### 1、什么是 SpringMvc？

答：SpringMvc 是 spring 的一个模块，基于 MVC 的一个框架，无需中间整合层来整合。

### 2、Spring MVC 的优点：

答：

1）它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java

组件.并且和 Spring 提供的其他基础结构紧密集成.

2）不依赖于 Servlet API(目标虽是如此,但是在实现的时候确实是依赖于 Servlet 的)

3）可以任意使用各种视图技术,而不仅仅局限于 JSP

4）支持各种请求资源的映射策略

5）它应是易于扩展的

### 3、SpringMVC 工作原理？

答：

1）客户端发送请求到 DispatcherServlet

2）DispatcherServlet 查询 handlerMapping 找到处理请求的 Controller

3）Controller 调用业务逻辑后，返回 ModelAndView

4）DispatcherServlet 查询 ModelAndView，找到指定视图

5）视图将结果返回到客户端

### 4、SpringMVC 流程？★★★★★

1）用户发送请求至前端控制器 DispatcherServlet。

2）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。

3）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器对象

及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。

更多关注 Java 大后端公众号 4）DispatcherServlet 调用 HandlerAdapter 处理器适配器。

5）HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)。

6）Controller 执行完成返回 ModelAndView。

7）HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。

8）DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。

9）ViewReslover 解析后返回具体 View。

10）DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。

11）DispatcherServlet 响应用户。

## 3、spring

![1709742703501](images/1、JAVA/1709742703501.png)

## BeanFactory和ApplicationContext有什么区别(不熟)

ApplicationContext接口作为BeanFactory的子类,除了提供BeanFactory所具有的功能外,还提供了更完整的框架功能:
①继承MessageSource,因此支持国际化
②资源文件访问，如URL和文件（ResourceLoader）
③载入多个（有继承关系）上下文（及同时加载多个配置文件），使得每一个上下文都专注于一个特定的层次
④提供在监听器中注册bean的事件；

## Spring是什么

Spring 是一个轻量级的控制翻转(IOC)和面向切面(AOP)的容器框架

从大小与开销两方面而言Spring都是轻量级的

包含并且管理Bean的配置和生命周期,又通过控制反转和依赖注入来达到松耦合, 在这个意义上是一个Bean容器,

提供了面向切面编程的丰富支持, 允许通过分离应用的业务逻辑和系统级 服务进行内聚性的开发
将简单的组件配置, 组合为复杂的应用, 这个意义上是一个框架
谈谈你对AOP的理解
系统是由许多不同的组件所组成的, 每一个组件各负责着一些功能, 除了主要业务功能之外, 有些组件比如日志, 事务管理和安全等服务会水平散布到所有对象层次中去,
OOP运行从上到下的关系但是并不适合定义从左到右的关系, 所以如果仍然按照OOP设计就会有大量代码的重复; 如果使用AOP就会将这些功能封装为一个切面, 然后注入到目标对象中, 而且AOP还可以对对象进行增强, 去做一些额外的事情.
谈谈你对IOC的理解
容器概念, 控制翻转, 依赖注入

(容器概念)IOC容器中存有自己配置获取的一些Bean(比如@Repository, @Service, @Controller), 在项目启动时使用反射创建对应的对象放到map中 ;(依赖注入) 这时候map中就有各种对象了, 接下来通过bean的配置文件中去获取xml文件中该bean节点下的, 根据其ref属性进行依赖注入, 注入到对应的注解下(@Autowired或者@Resource)
控制翻转: 控制翻转就是一个概念, 就是对象通过IOC容器和依赖注入自动进行装配, 就相当于原本属于程序员对对象创建的控制权交给了IOC
总结来说, 就是IOC通过容器概念, 控制翻转和依赖注入成为了整个系统的关键核心, 它起到一种类似"粘合剂"的作用, 把系统中的所有对象粘合起来一起发挥作用.

## 12.spring用了哪些设计模式

BeanFactory用了工厂模式，AOP用了动态代理模式，RestTemplate用来模板方法模式，SpringMVC中handlerAdaper用来适配器模式，Spring里的监听器用了观察者模式

## 14.SpringMV工作原理★★★★★

SpringMVC工作过程围绕着前端控制器DispatchServerlet，几个重要组件有HandleMapping（处理器映射器）、HandleAdapter（处理器适配器）、ViewReslover（试图解析器）

工作流程：

（1）DispatchServerlet接收用户请求将请求发送给HandleMapping

（2）HandleMapping根据请求url找到具体的handle和拦截器，返回给DispatchServerlet

（3）DispatchServerlet调用HandleAdapter,HandleAdapter执行具体的controller，并将controller返回的ModelAndView返回给DispatchServler

（4）DispatchServerlet将ModelAndView传给ViewReslover,ViewReslover解析后返回具体view

（5）DispatchServerlet根据view进行视图渲染，返回给用户

## 谈谈你对AOP的理解★★★★★

系统是由许多不同的组件所组成的, 每一个组件各负责着一些功能, 除了主要业务功能之外, 有些组件比如日志, 事务管理和安全等服务会水平散布到所有对象层次中去,
OOP运行从上到下的关系但是并不适合定义从左到右的关系, 所以如果仍然按照OOP设计就会有大量代码的重复; 如果使用AOP就会将这些功能封装为一个切面, 然后注入到目标对象中, 而且AOP还可以对对象进行增强, 去做一些额外的事情.

## 谈谈你对IOC的理解★★★★★

容器概念, 控制翻转, 依赖注入

(容器概念)IOC容器中存有自己配置获取的一些Bean(比如@Repository, @Service, @Controller), 在项目启动时使用反射创建对应的对象放到map中 ;(依赖注入) 这时候map中就有各种对象了, 接下来通过bean的配置文件中去获取xml文件中该bean节点下的, 根据其ref属性进行依赖注入, 注入到对应的注解下(@Autowired或者@Resource)
控制翻转: 控制翻转就是一个概念, 就是对象通过IOC容器和依赖注入自动进行装配, 就相当于原本属于程序员对对象创建的控制权交给了IOC
总结来说, 就是IOC通过容器概念, 控制翻转和依赖注入成为了整个系统的关键核心, 它起到一种类似"粘合剂"的作用, 把系统中的所有对象粘合起来一起发挥作用.

## bean的作用域

singleton：在Spring容器中仅存在一个实例，即Bean以单例的形式存在。
prototype：为每一个bean请求提供一个实例。
request ：每次HTTP请求都会创建一个新的Bean。
session：同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。
globalSession：同一个全局的Session共享一个Bean，一般用于Portlet环境

## .bean的自动装配

* @Autowried：通过byType方式实现，并且要求这个对象存在
* @Resouce：默认通过byName方式实现，如果name找不到再通过byType实现

### 1、什么是 Spring 框架？Spring 框架有哪些主要模块？

轻量级的开源的 J2EE 框架。它是一个容器框架，用来装 javabean（java 对象），中间层框架（万能胶） 可以起一个连接作用，比如说把 Struts 和 hibernate 粘合在一起运用，可以让我们的企业开发更快、更简 洁 Spring 是一个轻量级的控制反转（IoC)和面向切面（AOP）的容器框架

谈谈你对AOP的理解
AOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象
（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增
强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情

## 依赖注入的三种方式

> 常用的注入方式主要有三种：构造方法注入（Construct注入），setter注入，基于注解的注入（接口注入）

### 3、什么是控制反转(IOC)？什么是依赖注入？

控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象

之间耦合关系在编译时通常是未知的。在传统的编程方式中，业 务逻辑的流程是由应用程序中的早

已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来

决定的，该对象关系图由装配 器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽

象化。而绑定的过程是通过“依赖注入”实现的。

控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了

有效的作用。

依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实

例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的

基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？

## 在 Java 中依然注入有以下三种实现方式：★★★★★

1. 构造器注入
2. Setter 方法注入
3. 接口注入

### 4、请解释下 Spring 框架中的 IoC？

Spring 中的 org.springframework.beans 包和 org.springframework.context 包

构成了 Spring 框架 IoC 容器的基础。

BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。

ApplicationContex 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory

的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，也提供了处理 message resource

的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的

WebApplicationContext。

org.springframework.beans.factory.BeanFactory 是 Spring IoC 容器的具体实现，

用来包装和管理前面提到的各种 bean。BeanFactory 接口是 Spring IoC 容器的核心接口。

IOC:把对象的创建、初始化、销毁交给 spring 来管理，而不是由开发者控制，实现控制反转。

### 5、BeanFactory 和 ApplicationContext 有什么区别？

![1709478839382](images/1、JAVA/1709478839382.png)

BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在

接收到客户端请求时将对应的 bean 实例化。

BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的

配置中解放出来。BeanFactory 还包含 了 bean 生命周期的控制，调用客户端的初始化方法

（initialization methods）和销毁方法（destruction methods）。

从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，

根据请求分发 bean 的功能。但 applicationcontext 在此基础上还提供了其他的功能。

1. 提供了支持国际化的文本消息
2. 统一的资源文件读取方式
3. 已在监听器中注册的 bean 的事件

以下是三种较常见的 ApplicationContext 实现方式：

1、ClassPathXmlApplicationContext：从 classpath 的 XML 配置文件中读取上下文，并生成上

下文定义。应用程序上下文从程序环境变量中

ApplicationContext context = new

ClassPathXmlApplicationContext(“bean.xml”);

2、FileSystemXmlApplicationContext ：由文件系统中的 XML 配置文件读取上下文。

ApplicationContext context = new

FileSystemXmlApplicationContext(“bean.xml”);

3、XmlWebApplicationContext：由 Web 应用的 XML 文件读取上下文。

4.AnnotationConfigApplicationContext(基于 Java 配置启动容器)

![1708002876939](images/1、JAVA/1708002876939.png)

### 6、Spring 有几种配置方式？

将 Spring 配置到应用开发中有以下三种方式：

1. 基于 XML 的配置
2. 基于注解的配置
3. 基于 Java 的配置

1.什么是 spring?

Spring 是个 java 企业级应用的开源开发框架。Spring 主要用来开发 Java 应用，但是有些

扩展是针对构建 J2EE 平台的 web 应用。Spring 框架目标是简化 Java 企业级应用开发，并

通过 POJO 为基础的编程模型促进良好的编程习惯。

### 2.使用 Spring 框架的好处是什么？★★★★★

 轻量：Spring 是轻量的，基本的版本大约 2MB。

 控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建

或查找依赖的对象们。

 面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务

分开。

 容器：Spring 包含并管理应用中对象的生命周期和配置。

 MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。

 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事

务（JTA）。

 异常处理：Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，HibernateorJDO

抛出的）转化为一致的 unchecked 异常。

### 14.IOC 的优点是什么？

IOC 或依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和

JNDI 查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC 容器支持加载服务时

的饿汉式初始化和懒加载。

### 15.ApplicationContext 通常的实现是什么?

 FileSystemXmlApplicationContext：此容器从一个 XML 文件中加载 beans 的定义，

XMLBean 配置文件的全路径名必须提供给它的构造函数。

 ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载 beans 的定义，这

里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。

 WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个 WEB 应用的

所有 bean。

### 16.Bean 工厂和 Applicationcontexts 有什么区别？

Applicationcontexts 提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如

镜像），它们可以向注册为监听器的 bean 发布事件。另外，在容器或容器内的对象上执行

的那些不得不由 bean 工厂以程序化方式处理的操作，可以在 Applicationcontexts 中以声

明的方式处理。Applicationcontexts 实现了 MessageSource 接口，该接口的实现以可插拔

的方式提供获取本地化消息的方法。

### 19.有哪些不同类型的 IOC（依赖注入）方式？

更多关注 Java 大后端公众号  构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系

列参数，每个参数代表一个对其他类的依赖。

 Setter 方法注入：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂方法

实例化 bean 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注入。

### 11、 解释 Spring 支持的几种 bean 的作用域。

Spring 容器中的 bean 可以分为 5 个范围：

（1）singleton：默认，每个容器中只有一个 bean 的实例，单例的模式由 BeanFactory 自身来维护。

（2）prototype：为每一个 bean 请求提供一个实例。

（3）request：为每一个网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回 收。

（4）session：与 request 范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。

（5）global-session：全局作用域，global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器 中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局 变量需要存储在 global-session 中。全局作用域与 Servlet 中的 session 作用域效果相同。25.解释 Spring 支持的几种 bean 的作用域。★★★★★

## ★★★★★Spring 基于 xml 注入 bean 的几种方式：

（1）Set 方法注入；

（2）构造器注入：① 通过 index 设置参数的位置；② 通过 type 设置参数类型； （3）静态工厂注入； （4）实例工厂；

## Spring Boot、Spring MVC 和 Spring 有什么区别

spring 是一个 IOC 容器，用来管理 Bean，使用依赖注入实现控制反转，可以很方便的整合各种框架，提 供 AOP 机制弥补 OOP 的代码重复问题、更方便将不同类不同方法中的共同处理抽取成切面、自动注入给 方法执行，比如日志、异常等 springmvc 是 spring 对 web 框架的一个解决方案，提供了一个总的前端控制器 Servlet，用来接收请求， 然后定义了一套路由策略（url 到 handle 的映射）及适配执行 handle，将 handle 结果使用视图解析技术 生成视图展现给前端 springboot 是 spring 提供的一个快速开发工具包，让程序员能更方便、更快速的开发 spring+springmvc 应用，简化了配置（约定了默认配置），整合了一系列的解决方案（starter 机制）、redis、 mongodb、es，可以开箱即用

## #{}和\${}的区别是什么？★★★★★

#{}是预编译处理、是占位符， \${}是字符串替换、是拼接符。 Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 来赋值； Mybatis 在处理\${}时， 就是把\${}替换成变量的值，调用 Statement 来赋值； #{} 的变量替换是在 DBMS 中、变量替换后，#{} 对应的变量自动加上单引号 \${} 的变量替换是在 DBMS 外、变量替换后，\${} 对应的变量不会加上单引号 使用#{}可以有效的防止 SQL 注入， 提高系统安全性。

## 缓存雪崩、缓存穿透、缓存击穿★★★★★

4.缓存穿透、缓存击穿、缓存雪崩
缓存穿透：客户端查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。出现这种情况的原因，可能是业务层误将缓存和库中的数据删除了，也可能是有人恶意攻击，专门访问库中不存在的数据。
解决方案：缓存空对象；布隆过滤器
缓存击穿：一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。
解决方案：热点数据永不过期；加互斥锁
缓存雪崩
解决方案：设置过期时间时，附加一个随机数，避免数据同时过期；

缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内 承受大量请求而崩掉。 解决方案：

- 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
- 给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓 存。
- 缓存预热
- 互斥锁

缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承 受大量请求而崩掉。

- 解决方案： 接口层增加校验，如用户鉴权校验，id 做基础校验，id<=0 的直接拦截；
- 从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有 效时间可以设置短点，如 30 秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户 反复用同一个 id 暴力攻击
- 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据 会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力

缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同 时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪 崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查 数据库。

解决方案

- 设置热点数据永远不过期。
- 加互斥锁

# Mybatis

2、MyBatis 的优点和缺点 优点：

1. （1）基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重 用。
2. （2）与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；
3. （3）很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）。
4. （4）能够与 Spring 很好的集成； （5）提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系 组件维护。

缺点

1. （1）SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定 要求。
2. （2）SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。

## #{}和\${}的区别是什么？

#{}是预编译处理，\${}是字符串替换。 Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值； Mybatis 在处理\${}时，就是把\${}替换成变量的值。 使用#{}可以有效的防止 SQL 注入，提高系统安全性。

# 5、ES

### 1.为什么要使用 ES？

虽然 lucene 是性能最先进的、功能完善的搜索引擎，但是它只能有一个库，而且使用它需

要集成到 java 项目才能使用，配置还特别复杂,而 ES 语法简单、是基于 Resultful api 风格的,

它在 lucene 所有功能基础上还能集成多台服务器进行搜索，也就是集群;

### 2. ES 和 lucene 的区别是什么？

lucene 是现存功能最强大、最先进搜索库，直接基于 lucene 开发，api 非常复杂大量的 java

代码、需要深入了解原理

对比处:

只有一个索引库、

传统的遍历搜索方式

采用 B+树索引;

Es 是基于 lucene 的，隐藏了 lucene 复杂部分的一个分布式全文检索框架

对比处:

一个 es 的集群包含多个索引库、

分布式搜索

Es 是采用倒排式索引

es 没有事物概念,删除不能恢复

es 开源免费

正排索引：id ---> value

倒排索引：value ---> id

### 3.你还了解哪些全文检索工具？

Lucene，Solr，HadoopContrib，Katta

### 4.Bulk 一次最大处理多少数据量？

bulk 会把将要处理的数据载入内存中，所以数据量是有限制的

最佳的数据量不是一个确定的数值，它取决于你的硬件，你的文档大小以及复杂性，你的索

更多关注 Java 大后端公众号引以及搜索的负载。

一般建议是 1000-5000 个文档，如果你的文档很大，可以适当减少队列,大小建议是 5-15MB，

默认不能超过 100M，可以在 es 的配置文件中修改这个值 http.max_content_length: 100mb

### 5.ES 在高并发的情况下如何保证数据线程安全问题？

在读数据与写数据之间如果有其他线程进行写操作，就会出问题，es 使用版本控制才避免

这种问题

在修改数据的时候指定版本号，操作一次版本号加 1

### 6.ES 管理的工具有哪些？

1）BigDesk Plugin (作者 Luká? Vl?ek)：监控 es 状态的插件,推荐！主要提供的是节点的实时

状态监控，包括 jvm 的情况，linux 的情况，elasticsearch 的情况

2）Elasticsearch Head Plugin (作者 Ben Birch)：很方便对 es 进行各种操作的客户端。?

3）Kibana(ES 官方推荐)：Es 基于?RestAPI 调试、数据报表、数据搜索

### 7.ES 自动映射的规则？

Es 映射是用于确定字段类型，将新增的每个字段数据类型映射后确定的字段类型，常见的

映射类型有基本数据类型、复杂数据类型映射有数组对象(但对象映射扁平化后相关性会丢

失，不能确定哪个是哪个属性)、

全局映射的方式默认映射继承\_default\_的配置、动态模板映射：dynamic_templates，使用动

态模板映射会覆盖默认模板，可设置关键字分词，默认模板是 string 类型的。

# 6、面试

## 1、请你自我介绍一下你自己？

回答提示：一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历

上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究

的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习

无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。

企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”，企

业喜欢有礼貌的求职者。

## 2、你觉得你个性上最大的优点是什么？

回答提示：沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和

幽默感、乐观和友爱。

## 3、说说你最大的缺点？

回答提示：这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求

职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对

不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比

较出色，但事实上，他已经岌岌可危了。业喜欢求职者从自己的优点说起，中间加一些小缺

点，最后再把问题转回到优点上，突出优点的部分，企业喜欢聪明的求职者。

## 4、你对加班的看法？

回答提示：实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公

司奉献。

回答样本：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身

心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。

## 5、你对薪资的要求？

回答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，

那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，

因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这

笔钱是否足以引起你对该工作的兴趣。如果你自己必须说出具体数目，请不要说一个宽泛的

范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当

今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。

回答样本一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重

的是找对工作机会，所以只要条件公平，我则不会计较太多。

回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程

特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。

## 6、你的职业规划？

回答提示：这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多

的答案是“管理者”。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地

位往往被称作“顾问”、“参议技师”或“高级软件工程师”等等。当然，说出其他一些你感

兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的

工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧

失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司

的管理思路发展”。

## 7、你还有什么问题要问吗？

回答提示：企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，

因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人

这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋

升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的

上进心。

## 8、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，

你怎么办？

回答提示：一段时间发现工作不适合我，有两种情况：① 如果你确实热爱这个职业，那你就

要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业

要求，力争减少差距；② 你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，

你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。

## 9、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该

怎么做？

回答提示：①.原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，

婉转地表达自己的想法，看看领导是否能改变想法。② 如果领导没有采纳我的建议，我也同

样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原

则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。

## 10、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？

回答提示：① 我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法

去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。② 分清责任，各负其责，

如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，

作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。

③ 总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中

吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的

深度和力度是否不够，以致出现了本可以避免的错误。

更多关注 Java 大后端公众号 11、谈谈你对跳槽的看法？

回答提示：① 正常的“跳槽”能促进人才合理流动，应该支持。② 频繁的跳槽对单位和个人

双方都不利，应该反对。

## 12、工作中你难以和同事、上司相处，你该怎么办？

回答提示：① 我会服从领导的指挥，配合同事的工作。② 我会从自身找原因，仔细分析是不

是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，

如果是这样的话 我会努力改正。③ 如果我找不到原因，我会找机会跟他们沟通，请他们指

出我的不足，有问题就及时改正。④ 作为优秀的员工，应该时刻以大局为重，即使在一段时

间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看

见我在努力，总有一天会对我微笑的。

## 13、你对于我们公司了解多少？

回答提示：在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加

强与国外大厂的 OEM 合作，自有品牌的部分则透过海外经销商。

## 14、请说出你选择这份工作的动机？

回答提示：这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，

如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。

## 15、你最擅长的技术方向是什么？

回答提示：说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。

## 16、你能为我们公司带来什么呢？

回答提示：企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后

说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多

的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以

说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需

求和消费。”等等。

## 17、最能概括你自己的三个词是什么？

回答提示：我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主

考官解释，

## 18、为什么要离职?

回答提示：回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少

的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪

及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的

更多关注 Java 大后端公众号空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等

等，回答的答案最好是积极正面的。

回答样本：我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，

已经达到顶峰，即沒有升迁机会。

## 19、对工作的期望与目标何在？

回答提示：这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解

的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这

时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我

的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为

了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目

标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。

## 20、就你申请的这个职位，你认为你还欠缺什么？

回答提示：企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的

求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可

以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学

习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地

躲过难题的求职者。

## 21、你通常如何处理別人的批评？

回答提示：① 沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。② 我会

等大家冷靜下来再讨论。

## 22、怎样对待自己的失敗？

回答提示：我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。

## 23、什么会让你有成就感？

回答提示：为贵公司竭力效劳，尽我所能，完成一个项目。

## 24、你为什么愿意到我们公司来工作？

回答提示：对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些

详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，

我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市

场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你

已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。

## 25、你和别人发生过争执吗？你是怎样解决的？

更多关注 Java 大后端公众号回答提示：这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过

错，应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，

这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。

考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没

有外界干涉的情况下，通过妥协的方式来解决才是正确答案。

## 26、对这项工作，你有哪些可预见的困难？

回答提示：① 不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。② 可以尝试迂回

战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但

是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以

克服。

分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节，但常规思路中

的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的。第一，看看应

聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。第二，是想看一

下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难

的态度。

## 27、如果我录用你，你将怎样开展工作？

回答提示： ① 如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工

作的具体办法。② 可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就

有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开

展工作。”。

分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知

道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回

避的话，此人绝对不会录用了。

## 28、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应

该怎么做？与上级意见不一是，你将怎么办？

回答提示：①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，

婉转地表达自己的想法，看看领导是否能改变想法。② 如果领导没有采纳我的建议，我也同

样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原

则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。

## 29、你工作经验欠缺，如何能胜任这项工作？

常规思路：① 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在

乎“经验”，关键看应聘者怎样回答。② 对这个问题的回答最好要体现出应聘者的诚恳、机

智、果敢及敬业。③ 如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期

间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。

更多关注 Java 大后端公众号但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各

项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我

一定能胜任这个职位。”

点评：这个问题思路中的答案尚可，突出自己的吃苦能力和适应性以及学习能力（不是学习

成绩）为好。

## 30、您在前一家公司的离职原因是什么？

回答提示：① 最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”

在此家招聘单位里不存在。② 避免把“离职原因”说得太详细、太具体。③ 不能掺杂主观的

负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥

我们某某的员工”等。④ 但也不能躲闪、回避，如“想换换环境”、“个人原因”等。⑤ 不能

涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等。⑥ 尽量使解释的理由

为应聘者个人形象添彩。⑦ 相关例子：如“我离职是因为这家公司倒闭；我在公司工作了三

年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步

我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只

有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对

面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。

分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考

官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真

诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能

准假，所以辞职，这个答案一般面试官还能接受。

## 31、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？

回答提示：每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得

到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重

要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。

## 32、果你在这次面试中没有被录用，你怎么打算？

回答提示：现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有

优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅

仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方

面来正确看待这次失败：① 要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就

不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己

经历了这次之后经过努力一定能行，能够超越自我。② 善于反思，对于这次面试经验要认真

总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的

看待自己的长短得失，做一个明白人。③ 走出阴影，要克服这一次失败带给自己的心理压力，

时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④ 认真工作，回到原单位岗位

上后，要实实在在、踏踏实实地工作，三十六行、行行出状元，争取在本岗位上做出一定的

更多关注 Java 大后端公众号成绩。⑤ 再接再厉，成为国家公务员一直是我的梦想，以后如果有机会我仍然后再次参加竞

争。

## 33、谈谈你过去做过的成功案例？(工作中遇到什么问题)

回答提示：举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。切

忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电

话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿梆的。

## 34、如何安排自己的时间？会不会排斥加班？

回答提示：基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也

知道有时候很难避免加班，加上现在工作都采用责任制，所以我会调配自己的时间，全力配

合。

分析：虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。

## 35、这个职务的期许？

回答提示：希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、

我个人而言，缔造“双赢”的局面。

分析：回答前不妨先询问该公司对这项职务的责任认定及归属，因为每一家公司的状况不尽

相同，以免说了一堆理想抱负却发现牛头不对马嘴。

## 36、什么选择我们这家公司？

回答提示：曾经在报章杂志看过关于贵公司的报道，与自己所追求的理念有志一同。而贵公

司在业界的成绩也是有目共睹的，而且对员工的教育训练、升迁等也都很有制度。

分析：去面试前先做功课，了解一下该公司的背景，让对方觉得你真的很有心想得到这份工

作，而不只是探探路。

## 37、谈谈如何适应办公室工作的新环境？

回答提示：① 办公室里每个人有各自的岗位与职责，不得擅离岗位。② 根据领导指示和工作

安排，制定工作计划，提前预备，并按计划完成。③ 多请示并及时汇报，遇到不明白的要虚

心请教。④ 抓间隙时间，多学习，努力提高自己的政治素质和业务水平。

## 38、工作中学习到了些什么？

回答提示：这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来

回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学

习到哪些经验，把握这些要点做陈述，就可以轻易过关了。

## 39、除了本公司外，还应聘了哪些公司？

回答提示：很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，

更多关注 Java 大后端公众号所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，

如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。

## 40、何时可以到职？

回答提示：大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司规

定上班”，但如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至

少要一个月的时间，应进一步说明原因，录取公司应该会通融的。

# 7、redis

## 1.redis为什么快？

（1）完全基于内存操作

（2）数据结构简单，对数据操作简单

（3）redis执行命令是单线程的，避免了上下文切换带来的性能问题，也不用考虑锁的问题

(4) 采用了非阻塞的io多路复用机制，使用了单线程来处理并发的连接;内部采用的epoll+自己实现的事件分离器

其实Redis不是完全多线程的，在核心的网络模型中是多线程的用来处理并发连接，但是数据的操作都是单线程。Redis坚持单线程是因为Redis是的性能瓶颈是网络延迟而不是CPU，多线程对数据读取不会带来性能提升。

## Redis如何实现key的过期删除？★★★★★

采用的定期过期+惰性过期

定期删除 ：Redis 每隔一段时间从设置过期时间的 key 集合中，随机抽取一些 key ，检查是否过期，如果已经过期做删除处理。
惰性删除 ：Redis 在 key 被访问的时候检查 key 是否过期，如果过期则删除。

## 11.Redis缓存一致性解决方案

Redis缓存一致性解决方案主要思考的是删除缓存和更新数据库的先后顺序

先删除缓存后更新数据库存在的问题是可能会数据不一致，一般使用延时双删来解决，即先删除缓存，再更新数据库，休眠X秒后再次淘汰缓存。第二次删除可能导致吞吐率降低，可以考虑进行异步删除。

先更新数据库后删除缓存存在的问题是会可能会更新失败，可以采用延时删除。但由于读比写快，发生这一情况概率较小。

但是无论哪种策略，都可能存在删除失败的问题，解决方案是用中间件canal订阅binlog日志提取需要删除的key，然后另写一段非业务代码去获取key并尝试删除，若删除失败就把删除失败的key发送到消息队列，然后进行删除重试。

## 12.Redis内存淘汰策略

当内存不足时按设定好的策略进行淘汰，策略有(1)淘汰最久没使用的（2）淘汰一段时间内最少使用的（3）淘汰快要过期的

## 1、什么是 Redis？

Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载

在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。因为是纯

内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快

的 Key-Value DB。

Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结

构，此外单个 value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis

可以用来实现很多有用的功能，比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的

高性 能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。另外 Redis 也可以对存入

的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。

Redis

的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis

适合的场景主要局限在较小数据量的高性能操作和运算上。

## 2、Redis 相比 memcached 有哪些优势？

(1) memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型

(2) redis 的速度比 memcached 快很多

(3) redis 可以持久化其数据

## 3、Redis 支持哪几种数据类型？

String、List、Set、Sorted Set、hashes

字符串 String、字典 Hash、列表 List、集合 Set、有序集合 SortedSet。如果是高级用户，那

么还会有，如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog、

Geo、Pub/Sub。

## 4、Redis 主要消耗什么物理资源？

内存。

## 5、Redis 的全称是什么？

Remote Dictionary Server。

## 6、Redis 有哪几种数据淘汰策略？

noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部

分的写入指令，但 DEL 和几个例外）

allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。

volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有

空间存放。

allkeys-random: 回收随机的键使得新添加的数据有空间存放。

volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。

volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数

据有空间存放。

## 7、Redis 官方为什么不提供 Windows 版本？

因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来

兼容性等问题。

## 8、一个字符串类型的值能存储最大容量是多少？

512M

更多关注 Java 大后端公众号 9、为什么 Redis 需要把所有数据放到内存中？

Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。

所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I/O 速度为严重

影响 redis 的性能。在内存越来越便宜的今天，redis 将会越来越受欢迎。 如果设置了最大

使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。

## 10、Redis 集群方案应该怎么做？都有哪些方案？

1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通 redis 无任何区别，设

置好它下属的多个 redis 实例后，使用时在本需要连接 redis 的地方改为连接 twemproxy，它

会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 redis，将结果再

返回 twemproxy。使用方式简便(相对 redis 只需修改连接端口)，对旧项目扩展的首选。 问

题：twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的

计算值的改变，数据无法自动移动到新的节点。

2.codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量

改变情况下，旧节点数据可恢复到新 hash 节点。

3.redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概

念，以及自身支持节点设置从节点。具体看官方文档介绍。

4.在业务代码层实现，起几个毫无关联的 redis 实例，在代码层，对 key 进行 hash 计算，然

后去对应的 redis 实例操作数据。 这种方式对 hash 层代码要求比较高，考虑部分包括，节

点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。

## 11、Redis 集群方案什么情况下会导致整个集群不可用？

有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就

会以为缺少 5501-11000 这个范围的槽而不可用。

## 12、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点

数据？

redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

## 13、Redis 有哪些适合的场景？

更多关注 Java 大后端公众号（1）、会话缓存（Session Cache）

最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储

（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存

时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？

幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。

甚至广为人知的商业平台 Magento 也提供 Redis 的插件。

（2）、全页缓存（FPC）

除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了

Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改

进，类似 PHP 本地 FPC。

再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。

此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助

你以最快速度加载你曾浏览过的页面。

（3）、队列

Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很

好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）

对 list 的 push/pop 操作。

如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项

目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一

个后台就是使用 Redis 作为 broker，你可以从这里去查看。

（4），排行榜/计数器

Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted

Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结

构。所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，

我们只需要像下面一样执行即可：

更多关注 Java 大后端公众号当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你

需要这样执行：

ZRANGE user_scores 0 10 WITHSCORES

Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据

的，你可以在这里看到。

（5）、发布/订阅

最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常

多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用

Redis 的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。

## 14、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？

Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。

## 15、Redis 和 Redisson 有什么关系？

Redisson 是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些

Java 的 对 象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map,

ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore,

Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。

## 16、Jedis 与 Redisson 对比有什么优缺点？

Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；Redisson

实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，

不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关

注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。

## 17、Redis 如何设置密码及验证密码？

设置密码：config set requirepass 123456

授权密码：auth 123456

更多关注 Java 大后端公众号 18、说说 Redis 哈希槽的概念？

Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，

每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分

hash 槽。

## 19、Redis 集群的主从复制模型是怎样的？

为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主

从复制模型,每个节点都会有 N-1 个复制品.

## 20、Redis 集群会有写操作丢失吗？为什么？

Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操

作。

## 21、Redis 集群之间是如何复制的？

异步复制

## 22、Redis 集群最大节点个数是多少？

16384 个。

## 23、Redis 集群如何选择数据库？

Redis 集群目前无法做数据库选择，默认在 0 数据库。

## 24、怎么测试 Redis 的连通性？

ping

## 25、Redis 中的管道有什么用？

一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命

令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。

这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现

更多关注 Java 大后端公众号支持这个功能，大大加快了从服务器下载新邮件的过程。

## 26、怎么理解 Redis 事务？

事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的

过程中，不会被其他客户端发送来的命令请求所打断。

事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

## 27、Redis 事务相关的命令有哪几个？

MULTI、EXEC、DISCARD、WATCH

## 28、Redis key 的过期时间和永久有效分别怎么设置？

EXPIRE 和 PERSIST 命令。

## 29、Redis 如何做内存优化？

尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，

所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个

用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户

的所有信息存储到一张散列表里面.

## 30、Redis 回收进程如何工作的？

一个客户端运行了新的命令，添加了新的数据。

Redi 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。

一个新的命令被执行，等等。

所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。

如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不

用多久内存限制就会被这个内存使用量超越。

## 31、Redis 回收使用的是什么算法？

LRU 算法

## 32、Redis 如何做大量数据插入？

更多关注 Java 大后端公众号 Redis2.6 开始 redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工

作。

## 33、为什么要做 Redis 分区？

分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存。如果没有分区，你

最多只能使用一台机器的内存。分区使 Redis 的计算能力通过简单地增加计算机得到成倍提

升,Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。

## 34、你知道有哪些 Redis 分区实现方案？

客户端分区就是在客户端就已经决定数据会被存储到哪个 redis 节点或者从哪个 redis 节点读

取。大多数客户端已经实现了客户端分区。

代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。

代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。redis

和 memcached 的一种代理实现就是 Twemproxy

查询路由(Query routing) 的意思是客户端随机地请求任意一个 redis 实例，然后由 Redis 将请

求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接

将请求从一个 redis 节点转发到另一个 redis 节点，而是在客户端的帮助下直接 redirected 到

正确的 redis 节点。

## 35、Redis 分区有什么缺点？

涉及多个 key 的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储

到不同的 Redis 实例（实际上这种情况也有办法，但是不能直接使用交集指令）。

同时操作多个 key,则不能使用 Redis 事务.

分区使用的粒度是 key，不能使用一个非常长的排序 key 存储一个数据集（The partitioning

granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big

sorted set）.

当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的 Redis 实例和主机

同时收集 RDB / AOF 文件。

分区时动态扩容或缩容可能非常复杂。Redis 集群在运行时增加或者删除 Redis 节点，能做

到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这

种特性。然而，有一种预分片的技术也可以较好的解决这个问题。

## 36、Redis 持久化数据和缓存怎么做扩容？

更多关注 Java 大后端公众号如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。

如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数

量一旦确定不能变化。否则的话(即 Redis 节点需要动态变化的情况），必须使用可以在运行

时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。

## 37、分布式 Redis 是前期做还是后期规模上来了再做好？为什么？

既然 Redis 是如此的轻量（单实例只使用 1M 内存）,为防止以后的扩容，最好的办法就是一

开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式

运行，使用分区，在同一台服务器上启动多个实例。

一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可

能比较麻烦，但是从长久来看做这点牺牲是值得的。

这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis

实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了

另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。

## 38、Twemproxy 是什么？

Twemproxy 是 Twitter 维护的（缓存）代理系统，代理 Memcached 的 ASCII 协议和 Redis 协

议。它是单线程程序，使用 c 语言编写，运行起来非常快。它是采用 Apache 2.0 license 的开

源软件。 Twemproxy 支持自动分区，如果其代理的其中一个 Redis 节点不可用时，会自动

将该节点排除（这将改变原来的 keys-instances 的映射关系，所以你应该仅在把 Redis 当缓存

时使用 Twemproxy)。 Twemproxy 本身不存在单点问题，因为你可以启动多个 Twemproxy 实

例，然后让你的客户端去连接任意一个 Twemproxy 实例。 Twemproxy 是 Redis 客户端和服

务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。

## 39、支持一致性哈希的客户端有哪些？

Redis-rb、Predis 等。

## 40、Redis 与其他 key-value 存储有什么不同？

Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库

的进化路径。Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外

的抽象。

Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡

更多关注 Java 大后端公众号更多关注 Java 大后端公众号

内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上

相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很

强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要

进行随机访问。

## 41、Redis 的内存占用情况怎么样？

给你举个例子： 100 万个键值对（键是 0 到 999999 值是字符串“hello world”）在我的 32

位的 Mac 笔记本上 用了 100MB。同样的数据放到一个 key 里只需要 16MB，

这是因为键值

有一个很大的开销。 在 Memcached 上执行也是类似的结果，但是相对 Redis 的开销要小一

点点，因为 Redis 会记录类型信息引用计数等等。

当然，大键值对时两者的比例要好很多。

64 位的系统比 32 位的需要更多的内存开销，尤其是键值对都较小时，这是因为 64 位的系

统里指针占用了 8 个字节。 但是，当然，64 位系统支持更大的内存，所以为了运行大型的

Redis 服务器或多或少的需要使用 64 位的系统。

## 42、都有哪些办法可以降低 Redis 的内存使用情况呢？

如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set 等集合类型数据，

因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。

43、查看 Redis 使用情况及状态信息用什么命令？

info

## 44、Redis 的内存用完了会发生什么？

如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）或者

你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。

## 45、Redis 是单线程的，如何提高多核 CPU 的利用率？

可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时

候，无论如何一个服务器是不够的， 所以，如果你想使用多个 CPU，你可以考虑一下分片

（shard）。

## 46、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放了 2

亿 5 千万的 keys。我们正在测试一些较大的值。

任何 list、set、和 sorted set 都可以放 232 个元素。

换句话说，Redis 的存储极限是系统中的可用内存值。

## 47、Redis 常见性能问题和解决方案？

(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件

(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次

(3) 为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内

(4) 尽量避免在压力很大的主库上增加从库

(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <-

Slave3...

这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以

立刻启用 Slave1 做 Master，其他不变。

## 48、Redis 提供了哪几种持久化方式？

RDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储.

AOF 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢

复原始的数据,AOF 命令以 redis 协议追加保存每次写的操作到文件末尾.Redis 还能对 AOF 文

件进行后台重写,使得 AOF 文件的体积不至于过大.

如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.

你也可以同时开启两种持久化方式, 在这种情况下, 当 redis 重启的时候会优先载入 AOF 文

件来恢复原始的数据,因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集

要完整.

最重要的事情是了解 RDB 和 AOF 持久化方式的不同,让我们以 RDB 持久化方式开始。

## 49、如何选择合适的持久化方式？

一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化

更多关注 Java 大后端公众号功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只

使用 RDB 持久化。

有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot）

非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除

此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug。

## 50、修改配置不重启 Redis 会实时生效吗？

针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式

的重启。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要

重启 Redis。检索 ‘CONFIG GET \*’ 命令获取更多信息。

但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前

CONFIG 命令还不支持的配置参数的时候。

\\\\\\\\\\\\\\\\

# 8.MySQL

## 1\***\*、数据库的三范式是什么★★★★★**

第一范式：列不可再分

第二范式：行可以唯一区分，主键约束

第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束

且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。

## **2\*\***、数据库引擎有哪些\*\*

如何查看 mysql 提供的所有存储引擎

![1709735857375](images/1、JAVA/1709735857375.png)

`mysql> show engines;`

mysql 常用引擎包括：MYISAM、Innodb、Memory、MERGE

- MYISAM：全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对
- 较小，对事务完整性没有要求，以 select、insert 为主的应用基本上可以使用这引擎
- Innodb:行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持外键
- 约束，并发能力强，占用空间是 MYISAM 的 2.5 倍，处理效率相对会差一些
- Memory:全表锁，存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在 mysql 重
- 启时会丢失，默认使用 HASH 索引，检索效率非常高，但不适用于精确查找，主要用于那些内容变
- 化不频繁的代码表
- MERGE：是一组 MYISAM 表的组合

## **3\*\***、\***\*InnoDB\*\***与\***\*MyISAM\*\***的区别

1. InnoDB 支持事务，MyISAM 不支持，对于 InnoDB 每一条 SQL 语言都默认封装成事务，自动提交，

这样会影响速度，所以最好把多条 SQL 语言放在 begin 和 commit 之间，组成一个事务；

2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；
3. InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但

是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，

因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的

是数据文件的指针。主键索引和辅助索引是独立的。

4. InnoDB 不保存表的具体行数，执行 select count(\*) from table 时需要全表扫描。而 MyISAM 用一

个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；

5. Innodb 不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高；

mysql> show engines;**如何选择引擎？**

如果没有特别的需求，使用默认的 Innodb 即可。

MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。

Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如

OA 自动化办公系统。

**4\*\***、数据库的事务\*\*

## 4\***\*、数据库的事务★★★★★**

**什么是事务？**

**：** 多条 sql 语句，要么全部成功，要么全部失败。

**事务的特性：**

**数据库事务特性：原子性\*\***(Atomic)\***\*、一致性\*\***(Consistency)\***\*、隔离性\*\***(Isolation)\***\*、持久性\*\***(Durabiliy)\***\*。**

**简称\*\***ACID\***\*。**

原子性：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功，整个

事务才会提交。任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始状态。

一致性：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。如 A

转账 100 元给 B，不管操作是否成功，A 和 B 的账户总额是不变的。

隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰

持久性：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。

## 事务并发产生的三种问题

## 脏读：一个事务读取到了另外一个事务没有提交的数据

幻读：同一事务中，用同样的操作读取两次，得到的记录数不相同（数据条数）
不可重复读：在同一事务中，两次读取同一数据，得到内容不同（数据内容）
6.mysql的事务隔离级别
读未提交 Read uncommitted：一个事务还没有提交时，它做的变更就能被别的事务看到。
读提交 Read committed：一个事物提交之后，它做的变更才会被其他事务看到。
可重复读 Repeatable read：一个事物执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。未提交变更对其他事务也是不可见的。
串行化 serializable：对于同一行记录，写会加“写锁”，读会加“读锁”，当出现

## .innodb和myisam区别

innodb支持事务；myisam不支持事务
innodb支持外键；myisam不支持外键
innodb是聚集索引，数据和索引是捆绑在一起的；myisam是非聚集索引，数据和索引分开的，这也导致他们底层B+树结构不同。
innodb每个表下两个文件：.frm文件中保存的是表的结构，.ibd文件中保存的是数据和索引方式
myisam每个表下三个文件：一个文件用来保存 表结构，一个文件用来保存 数据，一个文件用来保存 索引

## **5**、索引问题

索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于快速获取信息。

你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，

索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅

速地找到表中的数据，而不必扫描整个数据库。

.索引
索引是帮助MySQL高效获取数据的数据结构，通俗来讲索引就好比书本的目录，加快数据库的查询速度。
分类
按功能逻辑分
主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
唯一索引：加速查询 + 列值唯一（可以有null）
普通索引：仅加速查询
组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
全文索引：对文本的内容进行分词，进行搜索
按物理结构分
聚簇索引
非聚簇索引★★★★★

mysql 有 4 种不同的索引：

1. 主键索引（PRIMARY）
2. 数据列不允许重复，不允许为 NULL，一个表只能有一个主键。
3. 唯一索引（UNIQUE）
4. 数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。
5. 可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引
6. 可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索
7. 引
8. 普通索引（INDEX）
9. 可以通过 ALTER TABLE table_name ADD INDEX index_name (column); 创建普通索引
10. 可以通过 ALTER TABLE table_name ADD INDEX index_name(column1, column2,
11. column3); 创建组合索引
12. 全文索引（FULLTEXT）
13. 可以通过 ALTER TABLE table_name ADD FULLTEXT (column); 创建全文索引

**索引并非是越多越好，创建索引也需要耗费资源，一是增加了数据库的存储空间，二是在插入和删除时**

**要花费较多的时间维护索引**

1. 索引加快数据库的检索速度
2. 索引降低了插入、删除、修改等维护任务的速度
3. 唯一索引可以确保每一行数据的唯一性
4. 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
5. 索引需要占物理和数据空间

## 6、SQL 优化

1、查询语句中不要使用 select \*

2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代

3、减少使用 IN 或者 NOT IN ,使用 exists，not exists 或者关联查询语句替代

4、or 的查询尽量用 union 或者 union all 代替(在确认没有重复数据或者不用剔除重复数据时，union

all 会更好)

5、应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。

6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫

描，如： select id from t where num is null 可以在 num 上设置默认值 0，确保表中 num 列没有 null

值，然后这样查询： select id from t where num=0

## **7\*\***、简单说一说\***\*drop\*\***、\***\*delete\*\***与\***\*truncate\*\***的区别\*\*

SQL 中的 drop、delete、truncate 都表示删除，但是三者有一些差别

delete 和 truncate 只删除表的数据不删除表的结构

速度,一般来说: drop> truncate >delete

delete 语句是 dml,这个操作会放到 rollback segement 中,事务提交之后才生效;

如果有相应的 trigger,执行的时候将被触发. truncate,drop 是 ddl, 操作立即生效,原数据不放到 rollback

segment 中,不能回滚. 操作不触发 trigger.

## **8\*\***、什么是视图\*\*

视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一

个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表

查询。

## **9\*\***、 什么是内联接、左外联接、右外联接？\*\*

1. 内联接（Inner Join）：匹配 2 张表中相关联的记录。
2. 左外联接（Left Outer Join）：除了匹配 2 张表中相关联的记录外，还会匹配左表中剩余的记录，
3. 右表中未匹配到的字段用 NULL 表示。
4. 右外联接（Right Outer Join）：除了匹配 2 张表中相关联的记录外，还会匹配右表中剩余的记录，
5. 左表中未匹配到的字段用 NULL 表示。在判定左表和右表时，要根据表名出现在 Outer Join 的左右
6. 位置关系。

## **10\*\***、并发事务带来哪些问题\***\*?\*\***隔离级别\*\*

**脏读**

**不可重复读**

**幻影读**

READ-UNCOMMITTED

√

√

√

READ-COMMITTED

×

√

√

REPEATABLE-READ

×

×

√

SERIALIZABLE

×

×

×

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一

数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

**脏读（\*\***Dirty read\***\*）\*\***:\*\* 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到

数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提

交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确

的。

**丢失修改（\*\***Lost to modify\***\*）\*\***:\*\* 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那

么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结

果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事

务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。

**不可重复读（\*\***Unrepeatableread\***\*）\*\***:\*\* 指在一个事务内多次读同一数据。在这个事务还没有结束

时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改

导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样

的情况，因此称为不可重复读。

**幻读（\*\***Phantom read\***\*）\*\***:\*\* 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接

着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了

一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

**不可重复读和幻读区别：**

不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者

删除比如多次读取一条记录发现记录增多或减少了。

## **11\*\***、事务隔离级别有哪些\***\*?MySQL\*\***的默认隔离级别是\***\*?**

**SQL** **标准定义了四个隔离级别：**

**READ-UNCOMMITTED(\*\***读取未提交\***\*)\*\***：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会\*\*

**导致脏读、幻读或不可重复读**。

**READ-COMMITTED(\*\***读取已提交\***\*)\*\***：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻\*\*

**读或不可重复读仍有可能发生**。

**REPEATABLE-READ(\*\***可重复读\***\*)\*\***：\*\* 对同一字段的多次读取结果都是一致的，除非数据是被本身事务

自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。

**SERIALIZABLE(\*\***可串行化\***\*)\*\***：\*\* 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执

行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻**

**读**。

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ\*\***（可重读）\*\*。我们可以通过

SELECT @@tx_isolation; 命令来查看这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 **REPEATABLE-READ\*\***（可重读）\*\*

事务隔离级别下使用的是 Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如

SQL Server) 是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ\*\***（可重\*\*

**读）** 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 **SERIALIZABLE(\*\***可串行化\***\*)** 隔离级

别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **READ**

**COMMITTED(\*\***读取提交内容\***\*)** ，但是你要知道的是 InnoDB 存储引擎默认使用 **REPEAaTABLE**

**READ\*\***（可重读）\*\* 并不会有任何性能损失。

InnoDB 存储引擎在 **分布式事务** 的情况下一般会用到 **SERIALIZABLE(\*\***可串行化\***\*)** 隔离级别。

## **12\*\***、大表如何优化？\*\*

当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下：

**1.** **限定数据的范围**

务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以

控制在一个月的范围内；

**2.** **读\*\***/\***\*写分离**

经典的数据库拆分方案，主库负责写，从库负责读；

**3.** **垂直分区**

**根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，

可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

**简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 如下图所示，这样来说大

家应该就更容易理解了。

**垂直拆分的优点：** 可以使得列数据变小，在查询时减少读取的 Block 数，减少 I/O 次数。此外，垂

直分区可以简化表的结构，易于维护。

**垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起 Join 操作，可以通过在应用层进行

Join 来解决。此外，垂直分区会让事务变得更加复杂；

**4.** **水平分区**

mysql> SELECT @@tx_isolation;

+-----------------+

| @@tx_isolation |

+-----------------+

| REPEATABLE-READ |

+-----------------+**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了**

**分布式的目的。 水平拆分可以支撑非常大的数据量。**

水平拆分是指数据表行的拆分，表的行数超过 200 万行时，就会变慢，这时可以把一张的表的数据拆成

多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据

量过大对性能造成影响。

水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但

由于表的数据还是在同一台机器上，其实对于提升 MySQL 并发能力没有什么意义，所以 **水平拆分最好**

**分库** 。

水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决** ，跨节点 Join 性能较

差，逻辑复杂。《Java 工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、**

**部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题

的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络 I/O。

**下面补充一下数据库分片的两种常见方案：**

**客户端代理： 分片逻辑在应用端，封装在\*\***jar\***\*包中，通过修改或者封装\*\***JDBC\***\*层来实现。** 当当网的

**Sharding-JDBC** 、阿里的 TDDL 是两种比较常用的实现。

**中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在

谈的 **Mycat** 、360 的 Atlas、网易的 DDB 等等都是这种架构的实现。

详细内容可以参考： MySQL 大表优化方案: https://segmentfault.com/a/1190000006158186

## **13\*\***、分库分表之后\***\*,id** **主键如何处理？**

因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来

支持。

生成全局 id 有下面这几种方式：

**UUID**：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的

名字的标示比如文件的名字。

**数据库自增** **id** : 两台数据库分别设置不同步长，生成不重复 ID 的策略来实现高可用。这种方式生成

的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。

**利用** **redis** **生成** **id :** 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更

加复杂，可用性降低，编码更加复杂，增加了系统成本。

**Twitter\*\***的\***\*snowflake\*\***算法\*\* ：Github 地址：https://github.com/twitter-archive/snowflake。

**美团的\*\***Leaf\***\*分布式\*\***ID\***\*生成系统** ：Leaf 是美团开源的分布式 ID 生成器，能保证全局唯一性、趋势递

增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、

Zookeeper 等中间件。感觉还不错。美团技术团队的一篇文章：https://tech.meituan.com/2017/

04/21/mt-leaf.html 。**14\*\***、\***\*mysql\*\***有关权限的表都有哪几个\*\*

MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库里，由

mysql_install_db 脚本初始化。这些权限表分别 user，db，table_priv，columns_priv 和 host。下面分

别介绍一下这些表的结构和内容：

user 权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。

db 权限表：记录各个帐号在各个数据库上的操作权限。

table_priv 权限表：记录数据表级的操作权限。

columns_priv 权限表：记录数据列级的操作权限。

host 权限表：配合 db 权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受

GRANT 和 REVOKE 语句的影响。

## **15\*\***、\***\*mysql\*\***有哪些数据类型\*\*

**1\*\***、整数类型\*\* ，包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示 1 字节、2 字节、3

字节、4 字节、8 字节整数。任何整数类型都可以加上 UNSIGNED 属性，表示数据是无符号的，即非负整

数。

长度：整数类型可以被指定长度，例如：INT(11)表示长度为 11 的 INT 类型。长度在大多数场景是没有意

义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和 UNSIGNED ZEROFILL 属性配

合使用才有意义。

例子，假定类型设定为 INT(5)，属性为 UNSIGNED ZEROFILL，如果用户插入的数据为 12 的话，那么数

据库实际存储数据为 00012。

**2\*\***、实数类型\*\*，包括 FLOAT、DOUBLE、DECIMAL。

DECIMAL 可以用于存储比 BIGINT 还大的整型，能存储精确的小数。

而 FLOAT 和 DOUBLE 是有取值范围的，并支持使用标准的浮点进行近似计算。

计算时 FLOAT 和 DOUBLE 相比 DECIMAL 效率更高一些，DECIMAL 你可以理解成是用字符串进行处理。

**3\*\***、字符串类型\*\*，包括 VARCHAR、CHAR、TEXT、BLOB

VARCHAR 用于存储可变长字符串，它比定长类型更节省空间。

VARCHAR 使用额外 1 或 2 个字节存储字符串长度。列长度小于 255 字节时，使用 1 字节表示，否则使用 2

字节表示。

VARCHAR 存储的内容超出设置的长度时，内容会被截断。

CHAR 是定长的，根据定义的字符串长度分配足够的空间。

CHAR 会根据需要使用空格进行填充方便比较。

CHAR 适合存储很短的字符串，或者所有值都接近同一个长度。

CHAR 存储的内容超出设置的长度时，内容同样会被截断。

**使用策略：**

对于经常变更的数据来说，CHAR 比 VARCHAR 更好，因为 CHAR 不容易产生碎片。

对于非常短的列，CHAR 比 VARCHAR 在存储空间上更有效率。

使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。

尽量避免使用 TEXT/BLOB 类型，查询时会使用临时表，导致严重的性能开销。

**4\*\***、枚举类型（\***\*ENUM\*\***）\*\*，把不重复的数据存储为一个预定义的集合。

有时可以使用 ENUM 代替常用的字符串类型。

ENUM 存储非常紧凑，会把列表值压缩到一个或两个字节。

ENUM 在内部存储时，其实存的是整数。

尽量避免使用数字作为 ENUM 枚举的常量，因为容易混乱。

排序是按照内部存储的整数**5\*\***、日期和时间类型\*\*，尽量使用 timestamp，空间效率高于 datetime，

用整数保存时间戳通常不方便处理。

如果需要存储微妙，可以使用 bigint 存储。

看到这里，这道真题是不是就比较容易回答了。

## **16\*\***、创建索引的三种方式，删除索引\*\*

第一种方式：在执行 CREATE TABLE 时创建索引

第二种方式：使用 ALTER TABLE 命令去增加索引

ALTER TABLE 用来创建普通索引、UNIQUE 索引或 PRIMARY KEY 索引。

其中 table_name 是要增加索引的表名，column_list 指出对哪些列进行索引，多列时各列之间用逗号分

隔。

索引名 index_name 可自己命名，缺省时，MySQL 将根据第一个索引列赋一个名称。另外，ALTER

TABLE 允许在单个语句中更改多个表，因此可以在同时创建多个索引。

第三种方式：使用 CREATE INDEX 命令创建

CREATE INDEX 可对表增加普通索引或 UNIQUE 索引。（但是，不能创建 PRIMARY KEY 索引）

删除索引

根据索引名删除普通索引、唯一索引、全文索引： alter table 表名 drop KEY 索引名

删除主键索引： alter table 表名 drop primary key （因为主键只有一个）。这里值得注意的是，

如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：

CREATE TABLE user_index2 (

id INT auto_increment PRIMARY KEY,

first_name VARCHAR (16),

last_name VARCHAR (16),

id_card VARCHAR (18),

information text,

KEY name (first_name, last_name),

FULLTEXT KEY (information),

UNIQUE KEY (id_card)

);

ALTER TABLE table_name ADD INDEX index_name (column_list);

CREATE INDEX index_name ON table_name (column_list);

alter table user_index drop KEY name;

alter table user_index drop KEY id_card;

alter table user_index drop KEY information;需要取消自增长再行删除：

但通常不会删除主键，因为设计主键一定与业务逻辑无关。

# 2、未分类

## 1、你知道的 List 都有哪些？

ArrayList、LinkedList、Vector 等。

## 2、List 和 Vector 有什么区别？

Vector 是 List 接口下线程安全的集合。

## 3、List 是有序的吗？

List 是有序的。

## 4、ArrayList 和 LinkedList 的区别？分别用在什么场景？

ArrayList 和 LinkedList 数据结构不一样，前者用在查询较多的场合，后者适用于插入较多的

场合。

## 5、ArrayList 和 LinkedList 的底层数据结构是什么？

ArrayList 使用的是数组结构，LinkedList 使用的是链表结构。

## 6、ArrayList 默认大小是多少，是如何扩容的？

Jdk1.7 之前 ArrayList 默认大小是 10，JDK1.7 之后是 0，JDK 差异，每次约按 1.5 倍扩容。

## 7、List 是线程安全的吗？如果要线程安全要怎么做？

List 中 的 Vector 才 是 线 程 安 全 的 ， 其 他 要 实 现 线 程 安 全 使 用 工 具 类

Collections.synchronizedList(new ArrayList())方法。

## 8、怎么给 List 排序？

使用 List 自身的 sort 方法，或者使用 Collections.sort(list)方法;

## 9、Arrays.asList 方法后的 List 可以扩容吗？

Arrays.asList 使用的是 final 数组，并且不支持 add 方法，不支持扩容。

## 10、List 和 Array 之间如何互相转换？

List>Array 使用 toArray 方法，Array>List 使用 Arrays.asList(array)方法，由于它是固定的，不固

定的可以使用 new ArrayList(Arrays.asList(array))。
